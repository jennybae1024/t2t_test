# coding=utf-8
# Copyright 2019 The Tensor2Tensor Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

r"""Data generators for the Mathematical Language Understanding dataset.
The training and test data were generated by assigning symbolic variables
either positive or negative decimal integers and then describing the algebraic
operation to perform. We restrict our variable assignments to the range
x,y->[-1000,1000) and the operations to the set {+,-,*}. To ensure that the
model embraces symbolic variables, the order in which x and y appears in the
expression is randomly chosen. For instance, an input string contrasting from
the example shown above might be y=129,x=531,x-y. Each input string is
accompanied by its target string, which is the evaluation of the mathematical
expression. For this study, all targets considered are decimal integers
represented at the character level. About 12 million unique samples were thus
generated and randomly split into training and test sets at an approximate
ratio of 9:1, respectively.
Example lines from training file:
y=691,x=-999,y*x:-690309
y=210,x=-995,y+x:-785
x=-995,y=210,x*x:990025
For more information check the following paper:
Artit Wangperawong. Attending to Mathematical Language with Transformers,
arXiv:1812.02825 (https://arxiv.org/abs/1812.02825).
"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import os
import tarfile
import requests

from tensor2tensor.data_generators import problem
from tensor2tensor.data_generators import text_problems
from tensor2tensor.utils import registry

import tensorflow as tf
import random
import numpy as np
import string



observed_ran = [i for i in range(-1000, 1000)]
unobserved_ran = [i for i in range(-2000, -1000)] +  [i for i in range(1000, 2000)]


@registry.register_problem
class AlgorithmicMemorizeTwoVariables(text_problems.Text2TextProblem):
    @property
    def vocab_type(self):
        return text_problems.VocabType.CHARACTER

    @property
    def dataset_splits(self):
        """Splits of data to produce and number of output shards for each."""
        return [{
            "split": problem.DatasetSplit.TRAIN,
            "shards": 1,
        }, {
            "split": problem.DatasetSplit.EVAL,
            "shards": 1,
        }, {
            "split": problem.DatasetSplit.TEST,
            "shards": 2,
        }]

    @property
    def num_train(self):
        return 100000

    @property
    def num_eval(self):
        return 2000

    @property
    def num_test(self):
        return 2000

    def generate_seq(self, first_num, second_num):
        variables = ['x', 'y']
        a = random.choice([0, 1])
        order = [a, (1-a)]
        values = {variables[order[0]]: first_num, variables[order[1]]: second_num}
        variables2 = random.choice(variables)
        res = ''
        res += variables[order[0]] + '=' + str(first_num) + ','
        res += variables[order[1]] + '=' + str(second_num) + ','
        res += variables2 + '='
        res2 = str(values[variables2])

        return res, res2

    def generate_initial_values(self, shard):
        if shard == 0:
            a = np.random.randint(-999, 1000)
            b = np.random.randint(-999, 1000)
        elif shard == 1:
            a = np.random.randint(-9999, 10000)
            b = np.random.randint(-9999, 10000)
        return a, b

    @property
    def is_generate_per_split(self):
        return True

    def generate_samples(self, data_dir, tmp_dir, dataset_split):
        del data_dir
        del tmp_dir

        if dataset_split == problem.DatasetSplit.TRAIN:
            num_data = self.num_train
            for num in range(num_data):
                a, b = self.generate_initial_values(0)
                enc, dec = self.generate_seq(a, b)
                yield {
                    "inputs": enc,
                    "targets": dec,
                }

        elif dataset_split == problem.DatasetSplit.EVAL:
            num_data = self.num_eval
            for num in range(num_data):
                a, b = self.generate_initial_values(1)
                enc, dec = self.generate_seq(a, b)
                yield {
                    "inputs": enc,
                    "targets": dec,
                }

        elif dataset_split == problem.DatasetSplit.TEST:
            num_data = self.num_test
            for num in range(num_data):
                for shard in range(2):
                    a, b = self.generate_initial_values(shard)
                    enc, dec = self.generate_seq(a, b)
                    yield {
                        "inputs": enc,
                        "targets": dec,
                    }

@registry.register_problem
class AlgorithmicMemorizeTwoVariablesV2(AlgorithmicMemorizeTwoVariables):
    def generate_initial_values(self, shard):
        TRAINING_INTERVAL = [i for i in range(-9999, -999)] + [i for i in range(1000, 10000)]
        TESTING_INTERVAL = [i for i in range(-999, 1000)]
        if shard == 0:
            a = random.choice(TRAINING_INTERVAL)
            b = random.choice(TRAINING_INTERVAL)
        elif shard == 1:
            a = random.choice(TESTING_INTERVAL)
            b = random.choice(TESTING_INTERVAL)
        return a, b


@registry.register_problem
class AlgorithmicMemorizeTwoVariablesV3(AlgorithmicMemorizeTwoVariables):
    def generate_initial_values(self, shard):
        TRAINING_INTERVAL = [i for i in range(-9999, -4999)] + [i for i in range(5000, 10000)]
        TESTING_INTERVAL = [i for i in range(-4999, -999)] + [i for i in range(1000, 5000)]
        if shard == 0:
            a = random.choice(TRAINING_INTERVAL)
            b = random.choice(TRAINING_INTERVAL)
        elif shard == 1:
            a = random.choice(TESTING_INTERVAL)
            b = random.choice(TESTING_INTERVAL)
        return a, b


class AlgorithmicMathTwoVariablesExtBase(text_problems.Text2TextProblem):
    @property
    def vocab_type(self):
        return text_problems.VocabType.CHARACTER

    @property
    def dataset_splits(self):
        raise NotImplementedError()

    def complete_eqn(self, first_num, second_num, operation):
        variables = ['x','y']
        order = random.choices([0, 1])
        order = [order[0], 0 if order[0] else 1]
        values = {variables[order[0]]:first_num, variables[order[1]]:second_num}
        variables2 = random.choices(variables, k=2)
        res = ''
        res += variables[order[0]] + '=' + str(first_num) + ','
        res += variables[order[1]] + '=' + str(second_num) + ','
        res += variables2[0] + operation + variables2[1]

        if operation == '+':
            res2 = str(values[variables2[0]]+values[variables2[1]])
        elif operation == '-':
            res2 = str(values[variables2[0]]-values[variables2[1]])
        elif operation == '*':
            res2 = str(values[variables2[0]]*values[variables2[1]])

        return res, res2

    def test_eqn(self, shard):
        if shard < 6:
            ran = observed_ran
        else:
            ran = unobserved_ran

        variables = ['x','y']
        order = random.choices([0, 1])
        order = [order[0], 0 if order[0] else 1]
        values = {variables[order[0]]:random.choices(ran)[0], variables[order[1]]:random.choices(ran)[0]}

        res = ''
        res += variables[order[0]] + '=' + str(values[variables[order[0]]]) + ','
        res += variables[order[1]] + '=' + str(values[variables[order[1]]]) + ','

        if shard % 6 == 0: # x+x
            var_of_interest = random.choices(variables)[0]
            res += var_of_interest + '+' + var_of_interest
            res2 = str(values[var_of_interest]+values[var_of_interest])

        if shard % 6 == 1: # x-x
            var_of_interest = random.choices(variables)[0]
            res += var_of_interest + '-' + var_of_interest
            res2 = str(values[var_of_interest]-values[var_of_interest])

        if shard % 6 == 2: # x*x
            var_of_interest = random.choices(variables)[0]
            res += var_of_interest + '*' + var_of_interest
            res2 = str(values[var_of_interest]*values[var_of_interest])

        if shard % 6 == 3: # x+y
            order2 = random.choices([0, 1])
            order2 = [order2[0], 0 if order2[0] else 1]
            var_of_interest = [variables[order2[0]], variables[order2[1]]]
            res += var_of_interest[0] + '+' + var_of_interest[1]
            res2 = str(values[var_of_interest[0]]+values[var_of_interest[1]])

        if shard % 6 == 4: # x-y
            order2 = random.choices([0, 1])
            order2 = [order2[0], 0 if order2[0] else 1]
            var_of_interest = [variables[order2[0]], variables[order2[1]]]
            res += var_of_interest[0] + '-' + var_of_interest[1]
            res2 = str(values[var_of_interest[0]]-values[var_of_interest[1]])

        if shard % 6 == 5: # x*y
            order2 = random.choices([0, 1])
            order2 = [order2[0], 0 if order2[0] else 1]
            var_of_interest = [variables[order2[0]], variables[order2[1]]]
            res += var_of_interest[0] + '*' + var_of_interest[1]
            res2 = str(values[var_of_interest[0]]*values[var_of_interest[1]])

        return res, res2

    @property
    def is_generate_per_split(self):
        return True

    def generate_samples(self, data_dir, tmp_dir, dataset_split):
        raise NotImplementedError()

@registry.register_problem
class AlgorithmicMathTwoVariablesExt(AlgorithmicMathTwoVariablesExtBase):
    """Mathematical language understanding, see arxiv.org/abs/1812.02825."""

    @property
    def dataset_splits(self):
        return [{
            "split": problem.DatasetSplit.TRAIN,
            "shards": 3,
        }, {
            "split": problem.DatasetSplit.EVAL,
            "shards": 1,
        }]

    def generate_samples(self, data_dir, tmp_dir, dataset_split):
        del data_dir
        del tmp_dir

        if dataset_split == problem.DatasetSplit.TRAIN:
            for first_num in range(-1000, 1000):
                for second_num in range(-1000, 1000):
                    for operation in ['+', '*', '-']:
                        enc, dec = self.complete_eqn(first_num, second_num, operation)
                        yield {"inputs": enc, "targets": dec}
        else:
            num_data = int(1e4)
            for num in range(num_data):
                enc, dec = self.test_eqn(random.randint(0, 12))
                yield {
                    "inputs": enc,
                    "targets": dec,
                }

@registry.register_problem
class AlgorithmicMathTwoVariablesExtTest(AlgorithmicMathTwoVariablesExtBase):
    """Mathematical language understanding, see arxiv.org/abs/1812.02825."""

    @property
    def dataset_splits(self):
        return [{
            "split": problem.DatasetSplit.TRAIN,
            "shards": 1,
        }, {
            "split": problem.DatasetSplit.EVAL,
            "shards": 12,
        }]

    def generate_samples(self, data_dir, tmp_dir, dataset_split):
        del data_dir
        del tmp_dir

        if dataset_split == problem.DatasetSplit.TRAIN:
            yield {"inputs": "y", "targets":"z"}
        else:
            num_data = 12*int(1e4)
            for num in range(num_data):
                enc, dec = self.test_eqn(num%12)
                yield {
                    "inputs": enc,
                    "targets": dec,
                }

@registry.register_problem
class AlgorithmicMathTwoVariablesExtTest1(AlgorithmicMathTwoVariablesExtBase):
    """Mathematical language understanding, see arxiv.org/abs/1812.02825."""

    @property
    def dataset_splits(self):
        return [{
            "split": problem.DatasetSplit.TRAIN,
            "shards": 1,
        }, {
            "split": problem.DatasetSplit.EVAL,
            "shards": 1,
        }]

    def generate_samples(self, data_dir, tmp_dir, dataset_split):
        del data_dir
        del tmp_dir

        if dataset_split == problem.DatasetSplit.TRAIN:
            yield {"inputs": "y", "targets":"z"}
        else:
            enc, dec = 'x=-1252,y=-1427,x+x', '-2504'
            yield {
                "inputs": enc,
                "targets": dec,
            }
